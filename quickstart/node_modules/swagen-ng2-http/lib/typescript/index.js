'use strict';

const _ = require('lodash');

const swagenCore = require('swagen-core');
const cli = swagenCore.cli;
const ts = require('swagen-typescript-language');

function getReturnType(operation) {
    if (!operation.responses) {
        return 'any';
    }

    let typeCount = 0;
    let returnType = '';
    for (let statusKey in operation.responses) {
        if (!operation.responses[statusKey].dataType) {
            continue;
        }
        typeCount++;
        if (returnType) {
            returnType += ' | ';
        }
        returnType += ts.getDataType(operation.responses[statusKey].dataType);
    }
    if (!returnType) {
        return 'any';
    }
    return typeCount > 1 ? `(${returnType})` : returnType;
}

function getMethodSignature(operationName, operation) {
    let parameters = '';
    for (let p = 0; p < (operation.parameters || []).length; p++) {
        let parameter = operation.parameters[p];
        if (parameters) {
            parameters += ', '
        }
        parameters += `${parameter.name}: ${ts.getDataType(parameter.dataType, parameter.name)}`;
    }

    let returnType = getReturnType(operation);

    let methodSig = `${operationName}(${parameters}): Observable<${returnType}>`;
    return methodSig;
}

module.exports = class Generator {
    constructor(definition, profile) {
        this.definition = definition;
        this.profile = profile;
        this.transform = new swagenCore.transformer.Transformer(profile);
        this.code = new swagenCore.CodeBuilder();
    }

    generate() {
        this.generateInitialCode();
        this.code.blank();
        this.generateServices();
        this.code.blank();
        this.generateModels();
        this.code.blank();
        this.generateEnums();
        return this.code.toCode();
    }

    generateInitialCode() {
        let header = ts.buildHeader(this.profile, this.definition);
        this.code.line(...header);

        this.code.blank();

        this.code.line(
            `import 'rxjs/Rx';`,
            `import { Observable } from 'rxjs/Observable';`,
            `import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';`,
            `import { Http, Headers, Response, RequestOptionsArgs } from '@angular/http';`
        );
    }

    generateServices() {
        for (let serviceName in this.definition.services) {
            let service = this.definition.services[serviceName];
            this.generateInterface(serviceName, service);
            this.code.blank();
            this.generateImplementation(serviceName, service);
            this.code.blank();
        }
        this.generateBuildUrlFunction();
        this.code.blank();
        this.generateHandleErrorFunction();
    }

    getTransformedServiceName(serviceName, service) {
        return this.transform.serviceName(serviceName, {
            service: service
        }) + (this.profile.options.serviceSuffix || 'Client');
    }

    generateInterface(serviceName, service) {
        let transformedServiceName = this.getTransformedServiceName(serviceName, service);
        this.code.line(`export interface I${transformedServiceName} {`).indent();
        for (let operationName in service) {
            let operation = service[operationName];
            let transformedOperationName = this.transform.operationName(operationName, {
                transformedServiceName,
                serviceName,
                service,
                operation
            });
            this.code.line(`${getMethodSignature(transformedOperationName, operation)};`)
        }
        this.code.unindent('}');
    }

    generateImplementation(serviceName, service) {
        let transformedServiceName = this.getTransformedServiceName(serviceName, service);

        let baseUrl = this.profile.options.baseUrl;
        let baseUrlVariable = baseUrl.variable || _.camelCase(baseUrl.provider);
        let baseUrlPath = baseUrl.path ? baseUrlVariable + '.' + baseUrl.path.join('.') : baseUrlVariable;

        this.code
            .line(`@Injectable`)
            .line(`export class ${transformedServiceName} implements I${transformedServiceName} {`)
                .indent(`private baseUrl: string;`)
                .blank()
                .line(`constructor(`)
                    .indent(`@Inject(Http) private http: Http,`)
                    .line(`@Optional @Inject(${baseUrl.provider}) ${baseUrlVariable}?: ${baseUrl.provider}`)
                .unindent(`) {`)
                    .indent(`this.baseUrl = ${baseUrlPath};`)
                .unindent(`}`);

        this.code.blank();

        for (let operationName in service) {
            let operation = service[operationName];
            let transformedOperationName = this.transform.operationName(operationName, {
                transformedServiceName,
                serviceName,
                service,
                operation
            });

            let docComments = ts.buildOperationDocComments(operation);
            this.code.line(...docComments);
            this.code.line(`public ${getMethodSignature(transformedOperationName, operation)} {`).indent();

            let requiredParams = (operation.parameters || []).filter(p => !!p.required);
            for (let i = 0; i < requiredParams.length; i++) {
                let requiredParam = requiredParams[i];
                this.code
                    .line(`if (${requiredParam.name} == undefined || ${requiredParam.name} == null) {`)
                        .indent(`throw new Error(\`The parameter '${requiredParam.name}' must be defined.\`);`)
                    .unindent(`}`);
            }

            let pathParams = (operation.parameters || []).filter(p => p.type === 'path');
            let hasPathParams = pathParams.length > 0;
            this.code
                .inline(`const resourceUrl: string = '${operation.path}'`)
                .inline(`;`, !hasPathParams)
                .done()
                .indent()
                    .repeat(pathParams, (cb, param, i) => {
                        cb.inline(`.replace('{${param.name}}', encodeURIComponent('' + ${param.name}))`)
                            .inline(';', i === pathParams.length - 1)
                            .done();
                    })
                .unindent();

            let queryParams = (operation.parameters || []).filter(p => p.type === 'query');
            let hasQueryParams = queryParams.length > 0;
            if (hasQueryParams) {
                this.code
                    .line(`const queryParams: {[key: string]: string} = {`)
                    .indent()
                        .repeat(queryParams, (cb, param, i) => {
                            cb.inline(`${param.name}: ${param.name}`)
                                .inline(',', i < queryParams.length - 1)
                                .done();
                        })
                    .unindent(`};`);
            }

            let bodyParam = (operation.parameters || []).find(p => p.type === 'body');
            let content = bodyParam ? `JSON.stringify(${bodyParam.name})` : `''`;

            let returnType = getReturnType(operation);

            this.code.inline(`const serviceUrl = buildServiceUrl(this.baseUrl, resourceUrl`)
                .inline(`, queryParams`, hasQueryParams)
                .inline(`);`)
                .done();

            this.code
                .line(`return this.http.request(serviceUrl, {`)
                    .indent(`method: '${operation.verb.toUpperCase()}',`)
                    .lineIf(bodyParam, `body: JSON.stringify(${(bodyParam || {}).name}),`)
                    .line(`headers: new Headers({`)
                        .indent(`'Content-Type': 'application/json; charset=UTF-8'`)
                    .unindent(`})`)
                .unindent(`}).map((response: Response) => {`)
                    .indent(`return this.__process_${transformedOperationName}(response);`)
                .unindent(`}).catch((response: any, caught: any) => {`)
                    .indent(`return handleError<${returnType}>(response, this.__process_${transformedOperationName});`)
                .unindent(`});`);

            this.code.unindent(`}`);

            this.code.blank();

            this.code
                .line(`private __process_${transformedOperationName}(response: Response): ${returnType} {`)
                    .indent(`const data: string = response.text();`)
                    .line(`const status: number = response.status;`);

            // If no responses declared. Should never be reached.
            if (!operation.responses) {
                this.code
                    .line(`if (status >= 200 && status < 300) {`)
                        .indent(`return undefined;`)
                    .unindent(`}`);
            }

            // Get array of status and response objects.
            let statuses = _.toPairs(operation.responses);

            // Check for a non-numeric status. If there is, then this is the default status, so just return undefined.
            let defaultStatus = statuses.find(s => isNaN(+s[0]));
            if (defaultStatus) {
                let statusValue = defaultStatus[1];
                if (statusValue.dataType) {
                    let dataTypeName = ts.getDataType(statusValue.dataType);
                    this.code
                        .line(`let result: ${dataTypeName} = data === '' ? undefined`)
                            .indent(`: <${dataTypeName}>JSON.parse(data)`)
                        .unindent(`return result;`);
                } else {
                    this.code.line(`return undefined;`);
                }
            } else {
                // Get all responses that have a data type.
                let dataTypeStatuses = statuses.filter(s => !!s[1].dataType);
                this.code.repeat(dataTypeStatuses, (cb, dataTypeStatus, i) => {
                    let statusKey = dataTypeStatus[0];
                    let status = dataTypeStatus[1];
                    let dataTypeName = ts.getDataType(status.dataType);
                    cb
                        .line(`if (status === ${statusKey}) {`)
                            .indent(`let result: ${dataTypeName} = data === '' ? undefined`)
                                .indent(`: <${dataTypeName}>JSON.parse(data)`)
                            .unindent(`return result;`)
                        .unindent(`}`);
                });

                // Combine all remaining responses and combine into a single return statement.
                let condition = statuses.filter(s => !s[1].dataType)
                    .map(s => `status === ${+s[0]}`)
                    .join(' || ');
                if (condition) {
                    this.code
                        .line(`if (${condition}) {`)
                            .indent(`return undefined;`)
                        .unindent(`}`);
                }
            }

            this.code.line(`throw new Error(\`Status code \${status} not supported for '${operation.verb.toUpperCase()} ${operation.path}' endpoint.\`);`);

            this.code.unindent(`}`);

            this.code.blank();
        }

        this.code.unindent(`}`);
    }

    generateBuildUrlFunction() {
        this.code.line(
            `function buildServiceUrl(baseUrl: string, resourceUrl: string, queryParams?: {[name: string]: string}): string {`,
            `    let url: string = baseUrl;`,
            `    let baseUrlSlash: boolean = url[url.length - 1] === '/';`,
            `    let resourceUrlSlash: boolean = resourceUrl[0] === '/';`,
            `    if (!baseUrlSlash && !resourceUrlSlash) {`,
            `        url += '/';`,
            `    } else if (baseUrlSlash && resourceUrlSlash) {`,
            `        url = url.substr(0, url.length - 1);`,
            `    }`,
            `    url += resourceUrl;`,
            ``,
            `    if (queryParams) {`,
            `        let queryString = _.keys(queryParams).map(p => \`\${p}=\${encodeURIComponent(queryParams[p])}\`).join('&');`,
            `        if (queryString) {`,
            `            url += '&' + queryString;`,
            `        }`,
            `    }`,
            ``,
            `    return url;`,
            `}`
        );
    }

    generateHandleErrorFunction() {
        this.code.line(
            `function handleError<T>(response: any, processor: (response: Response) => T): Observable<T> {`,
            `    if (response instanceof Response) {`,
            `        try {`,
            `            return Observable.of(processor(response));`,
            `        } catch (e) {`,
            `            return <Observable<T>><any>Observable.throw(e);`,
            `        }`,
            `    }`,
            `    return <Observable<T>><any>Observable.throw(response);`,
            `}`
        );
    }

    generateModels() {
        for (let modelName in this.definition.models) {
            let model = this.definition.models[modelName];
            this.code.line(`export interface ${modelName} {`);

            for (let propertyName in model) {
                let property = model[propertyName];
                this.code.line(`    ${propertyName}${property.required ? '?' : ''}: ${ts.getDataType(property, propertyName)};`);
            }

            this.code.line('}');
        }
    }

    generateEnums() {
        for (let serviceName in this.definition.services) {
            let service = this.definition.services[serviceName];
            for (let operationName in service) {
                let operation = service[operationName];
                for (let i = 0; i < operation.parameters.length; i++) {
                    let dataType = operation.parameters[i].dataType;
                    if (dataType.primitive && dataType.primitive === 'string' && dataType.subType === 'enum') {
                        let enumTypeName = _.upperFirst(_.camelCase(operation.parameters[i].name));
                        this.code.line(`export type ${enumTypeName}Enum = '${dataType.enumValues.join('\'|\'')}';`)
                    }
                }
            }
        }
    }
}
